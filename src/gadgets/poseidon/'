#ifndef SG_HALO2_POSEIDON_PRIMITIVES_HPP
#define SG_HALO2_POSEIDON_PRIMITIVES_HPP

#include <array>
#include <optional>
#include <algorithm>
#include <vector>
#include <iostream>

#include <group/ff.hpp>

using namespace group::ff;

namespace halo2::gadgets::poseidon {

    template <typename F, size_t T>
    using State = std::array<F, T>;
    
    template <typename F, size_t RATE>
    using SpongeRate = std::array<std::optional<F>, RATE>;
    
    template <typename F, size_t T>
    using Mds = std::array<std::array<F, T>, T>;

    template <typename F, size_t T, size_t RATE>
    struct Spec {
      static constexpr size_t full_rounds() {
        // The number of full rounds for this specification.
        // This must be an even number.
        return 0;
      }
    
      static constexpr size_t partial_rounds() {
        // The number of partial rounds for this specification.
        return 0;
      }
    
      static F sbox(const F& val) {
        // The S-box for this specification.
        return F(0);
      }
    
      static constexpr size_t secure_mds() {
        // Side-loaded index of the first correct and secure MDS that will be generated by
        // the reference implementation.
        // This is used by the default implementation of `constants()`. If you are
        // hard-coding the constants, you may leave this unimplemented.
        return 0;
      }
    
      static std::tuple<std::vector<std::array<F, T>>, Mds<F, T>, Mds<F, T>> constants() {
        // Generates `(round_constants, mds, mds^-1)` corresponding to this specification.
        return std::make_tuple(std::vector<std::array<F, T>>{}, Mds<F, T>{}, Mds<F, T>{});
      }
    };

    template <typename F, template <typename, std::size_t, std::size_t> class S, std::size_t T, std::size_t RATE>
    std::tuple<std::vector<std::array<F, T>>, Mds<F, T>, Mds<F, T>> generate_constants()
    {
        constexpr auto r_f = S<F, T, RATE>::full_rounds();
        constexpr auto r_p = S<F, T, RATE>::partial_rounds();
    
        Grain<F> grain(SboxType::Pow, T, r_f, r_p);
    
        std::vector<std::array<F, T>> round_constants(r_f + r_p);
        std::generate(round_constants.begin(), round_constants.end(), [&grain]() {
            std::array<F, T> rc_row;
            std::generate(rc_row.begin(), rc_row.end(), [&grain]() {
                return grain.next_field_element();
            });
            return rc_row;
        });
    
        const auto [mds, mds_inv] = generate_mds<F, T>(&grain, S<F, T, RATE>::secure_mds());
    
        return { round_constants, mds, mds_inv };
    }

    template <typename F, template <typename, std::size_t, std::size_t> class S, std::size_t T, std::size_t RATE>
    void permute(State<F, T>& state, const Mds<F, T>& mds, const std::vector<std::array<F, T>>& round_constants)
    {
        constexpr auto r_f = S<F, T, RATE>::full_rounds() / 2;
        constexpr auto r_p = S<F, T, RATE>::partial_rounds();
    
        const auto apply_mds = [&](State<F, T>& state) {
            State<F, T> new_state = {};
            // Matrix multiplication
            for (std::size_t i = 0; i < T; ++i) {
                for (std::size_t j = 0; j < T; ++j) {
                    new_state[i] += mds[i][j] * state[j];
                }
            }
            state = new_state;
        };
    
        const auto full_round = [&](State<F, T>& state, const std::array<F, T>& rcs) {
            for (std::size_t i = 0; i < T; ++i) {
                state[i] = S<F, T, RATE>::sbox(state[i] + rcs[i]);
            }
            apply_mds(state);
        };
    
        const auto part_round = [&](State<F, T>& state, const std::array<F, T>& rcs) {
            for (std::size_t i = 0; i < T; ++i) {
                state[i] += rcs[i];
            }
            // In a partial round, the S-box is only applied to the first state word.
            state[0] = S<F, T, RATE>::sbox(state[0]);
            apply_mds(state);
        };
    
        std::vector<std::function<void(State<F, T>&, const std::array<F, T>&)>> round_functions;
        round_functions.reserve(r_f + r_p);
        for (std::size_t i = 0; i < r_f; ++i) {
            round_functions.push_back(full_round);
        }
        for (std::size_t i = 0; i < r_p; ++i) {
            round_functions.push_back(part_round);
        }
        for (std::size_t i = 0; i < r_f; ++i) {
            round_functions.push_back(full_round);
        }
    
        auto round_constants_it = round_constants.cbegin();
        for (const auto& round_function : round_functions) {
            round_function(state, *round_constants_it++);
        }
    }



}

#endif 
